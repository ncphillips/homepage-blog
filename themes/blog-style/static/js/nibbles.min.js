class Board {
    constructor( cssSelector ){
        this._canvas = document.querySelector(cssSelector); 
        this._ctx = this._canvas.getContext("2d");

        this.backgroundColor = "lightgrey";
        this.fontSize = 120;
    }

    get getCenterX() {
        return Math.floor( this._canvas.width/2 );
    }

    get getCenterY() { 
        return Math.floor( this._canvas.height/2 );
    }

    clear() {
        this._ctx.fillStyle = this.backgroundColor;
        this._ctx.fillRect(0, 0, this._canvas.width, this._canvas.height );
    }

    reset(){
        this.clear();
    }

    drawSnake( snake ){
        this._ctx.fillStyle = snake.snakeColor;
        snake.tail.forEach(( pos ) => {
            this._ctx.fillRect( pos.x, pos.y, snake.size, snake.size );
        });
    }

    isOutOfBounds( snake ){
        let head = snake.getHead;
        return (head.x >= this._canvas.width || head.x < 0 || head.y >= this._canvas.height || head.y < 0 );
    }

    displayLoss(){
        let text = "You Lose";
        
        this._ctx.font = `${this.fontSize}px Comic Sans, Comic Sans MS, cursive`;
        this._ctx.fillStyle = "#FF2222";
        this._ctx.textAlign = "center";
        this._ctx.textBaseline = "middle";
        
        this._ctx.fillText(text, this._canvas.width/2, this._canvas.height/2);
    }

    generateMarker( diameter ){
        this._markerX = Math.floor( Math.random() * (this._canvas.width/diameter))*diameter;
        this._markerY = Math.floor( Math.random() * (this._canvas.height/diameter))*diameter;

        this._radius = Math.floor( diameter / 2 );
    }

    drawMarker(){
        this._ctx.beginPath();
        this._ctx.arc(this._markerX + this._radius, this._markerY + this._radius, this._radius, 0, 2 * Math.PI, false);
        this._ctx.fillStyle = '#FF00FF';
        this._ctx.fill();
        this._ctx.lineWidth = 0;
        this._ctx.strokeStyle = '#FF00FF';
        this._ctx.stroke();
    }

    hasHitMarker( snake ){
        let head = snake.getHead;
        return ( head.x === this._markerX && head.y === this._markerY);
    }
}
class GameController {

    constructor( board, snake ){
        this._board = board;
        this._snake = snake;

        this._snake.reset( board.getCenterX, board.getCenterY );
        this._board.generateMarker( snake.size );

        this._setupKeyPressMappings();
        this._setupTouchSupport();

        this.refreshRate = 50;
    }

    run(){
        if( !this.running )
        {
            setInterval( () => {
                this._board.clear();

                if(!this._gameStopped ){
                    this._snake.move();
                }

                if(this._snake.isTangled() || this._board.isOutOfBounds( this._snake )){
                    this._snake.stop();
                    this._board.displayLoss();
                    this._gameStopped = true;
                }

                if( this._board.hasHitMarker( this._snake )){
                    this._snake.grow();
                    this._board.generateMarker( this._snake.size );
                }
                
                this._board.drawMarker();
                this._board.drawSnake( this._snake );
            }, this.refreshRate);
        }

        this.running = true;
    }

    _setupKeyPressMappings(){
        const keymapping = {
            38 : () => this._snake.changeDirection(0, -1),
            87 : () => this._snake.changeDirection(0, -1),
            37 : () => this._snake.changeDirection(-1, 0),
            65 : () => this._snake.changeDirection(-1, 0),
            40 : () => this._snake.changeDirection(0, 1),
            83 : () => this._snake.changeDirection(0, 1),
            39 : () => this._snake.changeDirection(1, 0),
            68 : () => this._snake.changeDirection(1, 0),
            27 : () => {
                this._snake.reset( board.getCenterX, board.getCenterY  );
                this._board.reset();
                this._board.generateMarker( this._snake.size );
                this._gameStopped = false;
            },
        };

        document.addEventListener( "keydown", (event) =>{
            if( keymapping[event.keyCode] ){
                keymapping[event.keyCode]();
            }
        });
    }

    _setupTouchSupport(){

    }
}
class Snake {
    constructor( snakePieceSize ){
        this.portionSize = snakePieceSize;
        this.reset(0, 0);

        this.snakeColor = "green";
    }

    reset( xPos, yPos ){
        this.tail = [];
        this.tail.push({x: xPos, y: yPos});

        this.maxLength = 5;
        this.stop();
    }

    grow(){
        this.maxLength++;
    }

    stop(){
        this._xMovement = 0;
        this._yMovement = 0;
    }

    get size(){
        return this.portionSize;
    }

    //This seems like 4x duplication. How can I fix this?
    //changeDirection( 1, 0)? if check could check existing velocity *-1 if they are equal, dont change it

    changeDirection( x, y ){
        if( x !== 0 && this._xMovement * -1 === x ) return;
        if( y !== 0 && this._yMovement * -1 === y ) return;

        this._xMovement = x;
        this._yMovement = y;
    }

    directionLeft(){
        if( this._xMovement === 1 )
            return;

        this._xMovement = -1;
        this._yMovement = 0;
    }

    directionRight(){
        if( this._xMovement === -1 )
            return;

        this._xMovement = 1;
        this._yMovement = 0;
    }

    directionUp(){
        if( this._yMovement === 1 )
            return; 

        this._xMovement = 0;
        this._yMovement = -1;
    }

    directionDown(){
        if( this._yMovement === -1)
            return;

        this._xMovement = 0;
        this._yMovement = 1;
    }

    move(){
        if( this._xMovement === 0 && this._yMovement === 0 ){
            return;
        }

        let xPos = this.tail[ this.tail.length - 1 ].x + (this._xMovement * this.size );
        let yPos = this.tail[ this.tail.length - 1 ].y + (this._yMovement * this.size );

        this.tail.push({x: xPos, y: yPos});

        if( this.tail.length > this.maxLength){
            this.tail.shift();
        }
    }

    get getHead(){
        return this.tail[ this.tail.length -1 ];
    }

    //TODO this makes sure the x,y are exact. if it was smarter it would take
    //into consideration that this should be a range based on the size of the block
    //If we change the size of the board to a non-integer of 10, it may not ever work
    isTangled(){
        let head = this.getHead;
        let rest = this.tail.slice( 0, this.tail.length -1);

        return rest.some( snakeBit => {
            return( head.x === snakeBit.x && head.y === snakeBit.y);
        });
    }
}